{"ast":null,"code":"var _s = $RefreshSig$();\nimport { currencyEquals, ETHER, WETH } from '@pantherswap-libs/sdk';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useActiveWeb3React } from './index';\nimport { useWETHContract } from './useContract';\nexport let WrapType = /*#__PURE__*/function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n  return WrapType;\n}({});\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s();\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency);\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${inputAmount.toSignificant(6)} BNB to WBNB`\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance'\n      };\n    }\n    if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${inputAmount.toSignificant(6)} WBNB to BNB`\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WBNB balance'\n      };\n    }\n    return NOT_APPLICABLE;\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}\n_s(useWrapCallback, \"vntrhns1+yhOf5a8SvIDHA0AeGc=\", false, function () {\n  return [useActiveWeb3React, useWETHContract, useCurrencyBalance, useTransactionAdder];\n});","map":{"version":3,"names":["currencyEquals","ETHER","WETH","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWETHContract","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","_s","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"sources":["C:/projects/panther-frontend-dex1/src/hooks/useWrapCallback.ts"],"sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from '@pantherswap-libs/sdk'\r\nimport { useMemo } from 'react'\r\nimport { tryParseAmount } from '../state/swap/hooks'\r\nimport { useTransactionAdder } from '../state/transactions/hooks'\r\nimport { useCurrencyBalance } from '../state/wallet/hooks'\r\nimport { useActiveWeb3React } from './index'\r\nimport { useWETHContract } from './useContract'\r\n\r\nexport enum WrapType {\r\n  NOT_APPLICABLE,\r\n  WRAP,\r\n  UNWRAP\r\n}\r\n\r\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\r\n/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */\r\nexport default function useWrapCallback(\r\n  inputCurrency: Currency | undefined,\r\n  outputCurrency: Currency | undefined,\r\n  typedValue: string | undefined\r\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\r\n  const { chainId, account } = useActiveWeb3React()\r\n  const wethContract = useWETHContract()\r\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency)\r\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\r\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue])\r\n  const addTransaction = useTransactionAdder()\r\n\r\n  return useMemo(() => {\r\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\r\n\r\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\r\n\r\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\r\n      return {\r\n        wrapType: WrapType.WRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` })\r\n                  addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} BNB to WBNB` })\r\n                } catch (error) {\r\n                  console.error('Could not deposit', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient ETH balance'\r\n      }\r\n    } if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\r\n      return {\r\n        wrapType: WrapType.UNWRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`)\r\n                  addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WBNB to BNB` })\r\n                } catch (error) {\r\n                  console.error('Could not withdraw', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient WBNB balance'\r\n      }\r\n    }\r\n      return NOT_APPLICABLE\r\n\r\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}