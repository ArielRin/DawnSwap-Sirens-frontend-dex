{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubscribeBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(require(\"json-rpc-random-id\"));\nconst BaseBlockTracker_1 = require(\"./BaseBlockTracker\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nclass SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // parse + validate args\n    if (!opts.provider) {\n      throw new Error('SubscribeBlockTracker - no provider specified.');\n    }\n    // BaseBlockTracker constructor\n    super(opts);\n    // config\n    this._provider = opts.provider;\n    this._subscriptionId = null;\n  }\n  async checkForLatestBlock() {\n    return await this.getLatestBlock();\n  }\n  async _start() {\n    if (this._subscriptionId === undefined || this._subscriptionId === null) {\n      try {\n        const blockNumber = await this._call('eth_blockNumber');\n        this._subscriptionId = await this._call('eth_subscribe', 'newHeads');\n        this._provider.on('data', this._handleSubData.bind(this));\n        this._newPotentialLatest(blockNumber);\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n  async _end() {\n    if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n      try {\n        await this._call('eth_unsubscribe', this._subscriptionId);\n        this._subscriptionId = null;\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n  _call(method) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    return new Promise((resolve, reject) => {\n      this._provider.sendAsync({\n        id: createRandomId(),\n        method,\n        params,\n        jsonrpc: '2.0'\n      }, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res.result);\n        }\n      });\n    });\n  }\n  _handleSubData(_, response) {\n    var _a;\n    if (response.method === 'eth_subscription' && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {\n      this._newPotentialLatest(response.params.result.number);\n    }\n  }\n}\nexports.SubscribeBlockTracker = SubscribeBlockTracker;","map":{"version":3,"sources":["../src/SubscribeBlockTracker.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,oBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;AAEA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAGA,MAAM,cAAc,GAAG,CAAA,CAAA,EAAA,oBAAA,CAAA,OAAiB,EAAA,CAAE;AAY1C,MAAa,qBAAsB,SAAQ,kBAAA,CAAA,gBAAgB,CAAA;EAKzD,WAAA,CAAA,EAAmD;IAAA,IAAvC,IAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAqC,CAAA,CAAE;IACjD;IACA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;MAClB,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC;IAClE;IAED;IACA,KAAK,CAAC,IAAI,CAAC;IACX;IACA,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ;IAC9B,IAAI,CAAC,eAAe,GAAG,IAAI;EAC7B;EAEA,MAAM,mBAAmB,CAAA,EAAA;IACvB,OAAO,MAAM,IAAI,CAAC,cAAc,CAAA,CAAE;EACpC;EAEU,MAAM,MAAM,CAAA,EAAA;IACpB,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI,EAAE;MACvE,IAAI;QACF,MAAM,WAAW,GAAI,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAY;QACnE,IAAI,CAAC,eAAe,GAAI,MAAM,IAAI,CAAC,KAAK,CACtC,eAAe,EACf,UAAU,CACA;QACZ,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzD,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC;OACtC,CAAC,OAAO,CAAC,EAAE;QACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;MACtB;IACF;EACH;EAEU,MAAM,IAAI,CAAA,EAAA;IAClB,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;MACvE,IAAI;QACF,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,IAAI,CAAC,eAAe,CAAC;QACzD,IAAI,CAAC,eAAe,GAAG,IAAI;OAC5B,CAAC,OAAO,CAAC,EAAE;QACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;MACtB;IACF;EACH;EAEQ,KAAK,CAAC,MAAc,EAAsB;IAAA,SAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAjB,MAAiB,OAAA,KAAA,CAAA,IAAA,OAAA,IAAA,WAAA,IAAA,MAAA,IAAA,GAAA,IAAA,EAAA,IAAA;MAAjB,MAAiB,CAAA,IAAA,QAAA,SAAA,CAAA,IAAA;IAAA;IAChD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;MACrC,IAAI,CAAC,SAAS,CAAC,SAAS,CACtB;QACE,EAAE,EAAE,cAAc,CAAA,CAAE;QACpB,MAAM;QACN,MAAM;QACN,OAAO,EAAE;OACV,EACD,CAAC,GAAG,EAAE,GAAG,KAAI;QACX,IAAI,GAAG,EAAE;UACP,MAAM,CAAC,GAAG,CAAC;SACZ,MAAM;UACL,OAAO,CAAE,GAA+B,CAAC,MAAM,CAAC;QACjD;MACH,CAAC,CACF;IACH,CAAC,CAAC;EACJ;EAEQ,cAAc,CACpB,CAAU,EACV,QAA6D,EAAA;;IAE7D,IACE,QAAQ,CAAC,MAAM,KAAK,kBAAkB,IACtC,CAAA,CAAA,EAAA,GAAA,QAAQ,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,YAAY,MAAK,IAAI,CAAC,eAAe,EACtD;MACA,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;IACxD;EACH;AACD;AAhFD,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["import getCreateRandomId from 'json-rpc-random-id';\nimport { JsonRpcNotification, JsonRpcSuccess } from 'json-rpc-engine';\nimport { BaseBlockTracker } from './BaseBlockTracker';\nimport { Provider } from './types';\n\nconst createRandomId = getCreateRandomId();\n\nexport interface SubscribeBlockTrackerOptions {\n  provider?: Provider;\n  blockResetDuration?: number;\n}\n\ninterface SubscriptionNotificationParams {\n  subscription: string;\n  result: { number: string };\n}\n\nexport class SubscribeBlockTracker extends BaseBlockTracker {\n  private _provider: Provider;\n\n  private _subscriptionId: string | null;\n\n  constructor(opts: SubscribeBlockTrackerOptions = {}) {\n    // parse + validate args\n    if (!opts.provider) {\n      throw new Error('SubscribeBlockTracker - no provider specified.');\n    }\n\n    // BaseBlockTracker constructor\n    super(opts);\n    // config\n    this._provider = opts.provider;\n    this._subscriptionId = null;\n  }\n\n  async checkForLatestBlock(): Promise<string> {\n    return await this.getLatestBlock();\n  }\n\n  protected async _start(): Promise<void> {\n    if (this._subscriptionId === undefined || this._subscriptionId === null) {\n      try {\n        const blockNumber = (await this._call('eth_blockNumber')) as string;\n        this._subscriptionId = (await this._call(\n          'eth_subscribe',\n          'newHeads',\n        )) as string;\n        this._provider.on('data', this._handleSubData.bind(this));\n        this._newPotentialLatest(blockNumber);\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n\n  protected async _end() {\n    if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n      try {\n        await this._call('eth_unsubscribe', this._subscriptionId);\n        this._subscriptionId = null;\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n\n  private _call(method: string, ...params: unknown[]): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      this._provider.sendAsync(\n        {\n          id: createRandomId(),\n          method,\n          params,\n          jsonrpc: '2.0',\n        },\n        (err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve((res as JsonRpcSuccess<unknown>).result);\n          }\n        },\n      );\n    });\n  }\n\n  private _handleSubData(\n    _: unknown,\n    response: JsonRpcNotification<SubscriptionNotificationParams>,\n  ): void {\n    if (\n      response.method === 'eth_subscription' &&\n      response.params?.subscription === this._subscriptionId\n    ) {\n      this._newPotentialLatest(response.params.result.number);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}