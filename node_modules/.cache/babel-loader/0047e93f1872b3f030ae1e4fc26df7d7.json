{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\n// taken from ethers.js, compatible interface with web3 provider\n\nclass RequestError extends Error {\n  constructor(message, code, data) {\n    super(message);\n    this.code = code;\n    this.data = data;\n  }\n}\nclass MiniRpcProvider {\n  constructor(chainId, url, batchWaitTimeMs) {\n    this.isMetaMask = false;\n    this.chainId = void 0;\n    this.url = void 0;\n    this.host = void 0;\n    this.path = void 0;\n    this.batchWaitTimeMs = void 0;\n    this.nextId = 1;\n    this.batchTimeoutId = null;\n    this.batch = [];\n    this.clearBatch = async () => {\n      console.info('Clearing batch', this.batch);\n      const {\n        batch\n      } = this;\n      this.batch = [];\n      this.batchTimeoutId = null;\n      let response;\n      try {\n        response = await fetch(this.url, {\n          method: 'POST',\n          headers: {\n            'content-type': 'application/json',\n            accept: 'application/json'\n          },\n          body: JSON.stringify(batch.map(item => item.request))\n        });\n      } catch (error) {\n        batch.forEach(_ref => {\n          let {\n            reject\n          } = _ref;\n          return reject(new Error('Failed to send batch call'));\n        });\n        return;\n      }\n      if (!response.ok) {\n        batch.forEach(_ref2 => {\n          let {\n            reject\n          } = _ref2;\n          return reject(new RequestError(`${response.status}: ${response.statusText}`, -32000));\n        });\n        return;\n      }\n      let json;\n      try {\n        json = await response.json();\n      } catch (error) {\n        batch.forEach(_ref3 => {\n          let {\n            reject\n          } = _ref3;\n          return reject(new Error('Failed to parse JSON response'));\n        });\n        return;\n      }\n      const byKey = batch.reduce((memo, current) => {\n        memo[current.request.id] = current;\n        return memo;\n      }, {});\n      // eslint-disable-next-line no-restricted-syntax\n      for (const result of json) {\n        const {\n          resolve,\n          reject,\n          request: {\n            method\n          }\n        } = byKey[result.id];\n        if (resolve && reject) {\n          if ('error' in result) {\n            var _result$error, _result$error2, _result$error3;\n            reject(new RequestError(result === null || result === void 0 ? void 0 : (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message, result === null || result === void 0 ? void 0 : (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.code, result === null || result === void 0 ? void 0 : (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.data));\n          } else if ('result' in result) {\n            resolve(result.result);\n          } else {\n            reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n          }\n        }\n      }\n    };\n    this.sendAsync = (request, callback) => {\n      this.request(request.method, request.params).then(result => callback(null, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result\n      })).catch(error => callback(error, null));\n    };\n    this.request = async (method, params) => {\n      var _this$batchTimeoutId;\n      if (typeof method !== 'string') {\n        return this.request(method.method, method.params);\n      }\n      if (method === 'eth_chainId') {\n        return `0x${this.chainId.toString(16)}`;\n      }\n      const promise = new Promise((resolve, reject) => {\n        this.batch.push({\n          request: {\n            jsonrpc: '2.0',\n            id: this.nextId++,\n            method,\n            params\n          },\n          resolve,\n          reject\n        });\n      });\n      this.batchTimeoutId = (_this$batchTimeoutId = this.batchTimeoutId) !== null && _this$batchTimeoutId !== void 0 ? _this$batchTimeoutId : setTimeout(this.clearBatch, this.batchWaitTimeMs);\n      return promise;\n    };\n    this.chainId = chainId;\n    this.url = url;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname;\n    // how long to wait to batch calls\n    this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;\n  }\n}\nexport class NetworkConnector extends AbstractConnector {\n  constructor(_ref4) {\n    let {\n      urls,\n      defaultChainId\n    } = _ref4;\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');\n    super({\n      supportedChainIds: Object.keys(urls).map(k => Number(k))\n    });\n    this.providers = void 0;\n    this.currentChainId = void 0;\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);\n    this.providers = Object.keys(urls).reduce((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);\n      return accumulator;\n    }, {});\n  }\n  get provider() {\n    return this.providers[this.currentChainId];\n  }\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null\n    };\n  }\n  async getProvider() {\n    return this.providers[this.currentChainId];\n  }\n  async getChainId() {\n    return this.currentChainId;\n  }\n  async getAccount() {\n    return null;\n  }\n  deactivate() {\n    return null;\n  }\n}\nexport default NetworkConnector;","map":{"version":3,"names":["AbstractConnector","invariant","RequestError","Error","constructor","message","code","data","MiniRpcProvider","chainId","url","batchWaitTimeMs","isMetaMask","host","path","nextId","batchTimeoutId","batch","clearBatch","console","info","response","fetch","method","headers","accept","body","JSON","stringify","map","item","request","error","forEach","_ref","reject","ok","_ref2","status","statusText","json","_ref3","byKey","reduce","memo","current","id","result","resolve","_result$error","_result$error2","_result$error3","sendAsync","callback","params","then","jsonrpc","catch","_this$batchTimeoutId","toString","promise","Promise","push","setTimeout","parsed","URL","pathname","NetworkConnector","_ref4","urls","defaultChainId","Object","keys","length","supportedChainIds","k","Number","providers","currentChainId","accumulator","provider","activate","account","getProvider","getChainId","getAccount","deactivate"],"sources":["C:/projects/panther-frontend-dex1/src/connectors/NetworkConnector.ts"],"sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\r\nimport { AbstractConnector } from '@web3-react/abstract-connector'\r\nimport invariant from 'tiny-invariant'\r\n\r\ninterface NetworkConnectorArguments {\r\n  urls: { [chainId: number]: string }\r\n  defaultChainId?: number\r\n}\r\n\r\n// taken from ethers.js, compatible interface with web3 provider\r\ntype AsyncSendable = {\r\n  isMetaMask?: boolean\r\n  host?: string\r\n  path?: string\r\n  sendAsync?: (request: any, callback: (error: any, response: any) => void) => void\r\n  send?: (request: any, callback: (error: any, response: any) => void) => void\r\n}\r\n\r\nclass RequestError extends Error {\r\n  constructor(message: string, public code: number, public data?: unknown) {\r\n    super(message)\r\n  }\r\n}\r\n\r\ninterface BatchItem {\r\n  request: { jsonrpc: '2.0'; id: number; method: string; params: unknown }\r\n  resolve: (result: any) => void\r\n  reject: (error: Error) => void\r\n}\r\n\r\nclass MiniRpcProvider implements AsyncSendable {\r\n  public readonly isMetaMask: false = false\r\n\r\n  public readonly chainId: number\r\n\r\n  public readonly url: string\r\n\r\n  public readonly host: string\r\n\r\n  public readonly path: string\r\n\r\n  public readonly batchWaitTimeMs: number\r\n\r\n  private nextId = 1\r\n\r\n  private batchTimeoutId: ReturnType<typeof setTimeout> | null = null\r\n\r\n  private batch: BatchItem[] = []\r\n\r\n  constructor(chainId: number, url: string, batchWaitTimeMs?: number) {\r\n    this.chainId = chainId\r\n    this.url = url\r\n    const parsed = new URL(url)\r\n    this.host = parsed.host\r\n    this.path = parsed.pathname\r\n    // how long to wait to batch calls\r\n    this.batchWaitTimeMs = batchWaitTimeMs ?? 50\r\n  }\r\n\r\n  public readonly clearBatch = async () => {\r\n    console.info('Clearing batch', this.batch)\r\n    const { batch } = this\r\n    this.batch = []\r\n    this.batchTimeoutId = null\r\n    let response: Response\r\n    try {\r\n      response = await fetch(this.url, {\r\n        method: 'POST',\r\n        headers: { 'content-type': 'application/json', accept: 'application/json' },\r\n        body: JSON.stringify(batch.map((item) => item.request)),\r\n      })\r\n    } catch (error) {\r\n      batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')))\r\n      return\r\n    }\r\n\r\n    if (!response.ok) {\r\n      batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)))\r\n      return\r\n    }\r\n\r\n    let json\r\n    try {\r\n      json = await response.json()\r\n    } catch (error) {\r\n      batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')))\r\n      return\r\n    }\r\n    const byKey = batch.reduce<{ [id: number]: BatchItem }>((memo, current) => {\r\n      memo[current.request.id] = current\r\n      return memo\r\n    }, {})\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    for (const result of json) {\r\n      const {\r\n        resolve,\r\n        reject,\r\n        request: { method },\r\n      } = byKey[result.id]\r\n      if (resolve && reject) {\r\n        if ('error' in result) {\r\n          reject(new RequestError(result?.error?.message, result?.error?.code, result?.error?.data))\r\n        } else if ('result' in result) {\r\n          resolve(result.result)\r\n        } else {\r\n          reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public readonly sendAsync = (\r\n    request: { jsonrpc: '2.0'; id: number | string | null; method: string; params?: any },\r\n    callback: (error: any, response: any) => void\r\n  ): void => {\r\n    this.request(request.method, request.params)\r\n      .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))\r\n      .catch((error) => callback(error, null))\r\n  }\r\n\r\n  public readonly request = async (\r\n    method: string | { method: string; params: unknown[] },\r\n    params?: any\r\n  ): Promise<unknown> => {\r\n    if (typeof method !== 'string') {\r\n      return this.request(method.method, method.params)\r\n    }\r\n    if (method === 'eth_chainId') {\r\n      return `0x${this.chainId.toString(16)}`\r\n    }\r\n    const promise = new Promise((resolve, reject) => {\r\n      this.batch.push({\r\n        request: {\r\n          jsonrpc: '2.0',\r\n          id: this.nextId++,\r\n          method,\r\n          params,\r\n        },\r\n        resolve,\r\n        reject,\r\n      })\r\n    })\r\n    this.batchTimeoutId = this.batchTimeoutId ?? setTimeout(this.clearBatch, this.batchWaitTimeMs)\r\n    return promise\r\n  }\r\n}\r\n\r\nexport class NetworkConnector extends AbstractConnector {\r\n  private readonly providers: { [chainId: number]: MiniRpcProvider }\r\n\r\n  private currentChainId: number\r\n\r\n  constructor({ urls, defaultChainId }: NetworkConnectorArguments) {\r\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url')\r\n    super({ supportedChainIds: Object.keys(urls).map((k): number => Number(k)) })\r\n\r\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0])\r\n    this.providers = Object.keys(urls).reduce<{ [chainId: number]: MiniRpcProvider }>((accumulator, chainId) => {\r\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)])\r\n      return accumulator\r\n    }, {})\r\n  }\r\n\r\n  public get provider(): MiniRpcProvider {\r\n    return this.providers[this.currentChainId]\r\n  }\r\n\r\n  public async activate(): Promise<ConnectorUpdate> {\r\n    return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null }\r\n  }\r\n\r\n  public async getProvider(): Promise<MiniRpcProvider> {\r\n    return this.providers[this.currentChainId]\r\n  }\r\n\r\n  public async getChainId(): Promise<number> {\r\n    return this.currentChainId\r\n  }\r\n\r\n  public async getAccount(): Promise<null> {\r\n    return null\r\n  }\r\n\r\n  public deactivate() {\r\n    return null\r\n  }\r\n}\r\n\r\nexport default NetworkConnector\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}