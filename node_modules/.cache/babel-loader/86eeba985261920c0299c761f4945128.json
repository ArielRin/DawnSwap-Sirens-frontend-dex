{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token, currencyEquals } from '@pantherswap-libs/sdk';\nimport { useMemo } from 'react';\nimport { useSelectedTokenList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\n// eslint-disable-next-line import/no-cycle\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useActiveWeb3React } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nexport function useAllTokens() {\n  _s();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useSelectedTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens\n    // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    },\n    // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    {\n      ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n}\n\n// Check if currency is included in custom list from user storage\n_s(useAllTokens, \"j7VLVC0kwHLk93LfVYEfD5N0DOQ=\", false, function () {\n  return [useActiveWeb3React, useUserAddedTokens, useSelectedTokenList];\n});\nexport function useIsUserAddedToken(currency) {\n  _s2();\n  const userAddedTokens = useUserAddedTokens();\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n}\n\n// parse a name or symbol from a token response\n_s2(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : bytes32 && BYTES32_REGEX.test(bytes32) ? parseBytes32String(bytes32) : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress) {\n  _s3();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address || undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\n_s3(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\nexport function useCurrency(currencyId) {\n  _s4();\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'ETH';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n_s4(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"names":["parseBytes32String","ETHER","Token","currencyEquals","useMemo","useSelectedTokenList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","useAllTokens","_s","chainId","userAddedTokens","allTokens","reduce","tokenMap","token","address","useIsUserAddedToken","currency","_s2","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","_s3","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","_symbol$result","_symbolBytes32$result","_tokenName$result","_tokenNameBytes32$res","useCurrency","currencyId","_s4","isETH","toUpperCase"],"sources":["C:/projects/panther-frontend-dex1/src/hooks/Tokens.ts"],"sourcesContent":["import { parseBytes32String } from '@ethersproject/strings'\r\nimport { Currency, ETHER, Token, currencyEquals } from '@pantherswap-libs/sdk'\r\nimport { useMemo } from 'react'\r\nimport { useSelectedTokenList } from '../state/lists/hooks'\r\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\r\n// eslint-disable-next-line import/no-cycle\r\nimport { useUserAddedTokens } from '../state/user/hooks'\r\nimport { isAddress } from '../utils'\r\n\r\nimport { useActiveWeb3React } from './index'\r\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\r\n\r\nexport function useAllTokens(): { [address: string]: Token } {\r\n  const { chainId } = useActiveWeb3React()\r\n  const userAddedTokens = useUserAddedTokens()\r\n  const allTokens = useSelectedTokenList()\r\n\r\n  return useMemo(() => {\r\n    if (!chainId) return {}\r\n    return (\r\n      userAddedTokens\r\n        // reduce into all ALL_TOKENS filtered by the current chain\r\n        .reduce<{ [address: string]: Token }>(\r\n          (tokenMap, token) => {\r\n            tokenMap[token.address] = token\r\n            return tokenMap\r\n          },\r\n          // must make a copy because reduce modifies the map, and we do not\r\n          // want to make a copy in every iteration\r\n          { ...allTokens[chainId] }\r\n        )\r\n    )\r\n  }, [chainId, userAddedTokens, allTokens])\r\n}\r\n\r\n// Check if currency is included in custom list from user storage\r\nexport function useIsUserAddedToken(currency: Currency): boolean {\r\n  const userAddedTokens = useUserAddedTokens()\r\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token))\r\n}\r\n\r\n// parse a name or symbol from a token response\r\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\r\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\r\n  return str && str.length > 0\r\n    ? str\r\n    : bytes32 && BYTES32_REGEX.test(bytes32)\r\n    ? parseBytes32String(bytes32)\r\n    : defaultValue\r\n}\r\n\r\n// undefined if invalid or does not exist\r\n// null if loading\r\n// otherwise returns the token\r\nexport function useToken(tokenAddress?: string): Token | undefined | null {\r\n  const { chainId } = useActiveWeb3React()\r\n  const tokens = useAllTokens()\r\n\r\n  const address = isAddress(tokenAddress)\r\n\r\n  const tokenContract = useTokenContract(address || undefined, false)\r\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false)\r\n  const token: Token | undefined = address ? tokens[address] : undefined\r\n\r\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\r\n  const tokenNameBytes32 = useSingleCallResult(\r\n    token ? undefined : tokenContractBytes32,\r\n    'name',\r\n    undefined,\r\n    NEVER_RELOAD\r\n  )\r\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\r\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\r\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\r\n\r\n  return useMemo(() => {\r\n    if (token) return token\r\n    if (!chainId || !address) return undefined\r\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\r\n    if (decimals.result) {\r\n      return new Token(\r\n        chainId,\r\n        address,\r\n        decimals.result[0],\r\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\r\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\r\n      )\r\n    }\r\n    return undefined\r\n  }, [\r\n    address,\r\n    chainId,\r\n    decimals.loading,\r\n    decimals.result,\r\n    symbol.loading,\r\n    symbol.result,\r\n    symbolBytes32.result,\r\n    token,\r\n    tokenName.loading,\r\n    tokenName.result,\r\n    tokenNameBytes32.result,\r\n  ])\r\n}\r\n\r\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\r\n  const isETH = currencyId?.toUpperCase() === 'ETH'\r\n  const token = useToken(isETH ? undefined : currencyId)\r\n  return isETH ? ETHER : token\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}