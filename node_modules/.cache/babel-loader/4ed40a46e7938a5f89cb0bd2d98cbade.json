{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nexport class HttpConnection {\n  constructor(url) {\n    let disableProviderPing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.url = url;\n    this.disableProviderPing = disableProviderPing;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    this.url = url;\n    this.disableProviderPing = disableProviderPing;\n  }\n  get connected() {\n    return this.isAvailable;\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n  async close() {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n    this.onClose();\n  }\n  async send(payload, context) {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      const data = await res.json();\n      this.onPayload({\n        data\n      });\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n  async register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (this.events.listenerCount(\"register_error\") >= currentMaxListeners || this.events.listenerCount(\"open\") >= currentMaxListeners) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n          resolve();\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    try {\n      if (!this.disableProviderPing) {\n        const body = safeJsonStringify({\n          id: 1,\n          jsonrpc: \"2.0\",\n          method: \"test\",\n          params: []\n        });\n        await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n          body\n        }));\n      }\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n  onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n  onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n  resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n}\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nexport class HttpConnection {\n    constructor(url, disableProviderPing = false) {\n        this.url = url;\n        this.disableProviderPing = disableProviderPing;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n        this.disableProviderPing = disableProviderPing;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            const currentMaxListeners = this.events.getMaxListeners();\n            if (this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n                this.events.listenerCount(\"open\") >= currentMaxListeners) {\n                this.events.setMaxListeners(currentMaxListeners + 1);\n            }\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    this.resetMaxListeners();\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    this.resetMaxListeners();\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            if (!this.disableProviderPing) {\n                const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n                await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            }\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n    resetMaxListeners() {\n        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n        }\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}